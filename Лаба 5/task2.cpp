// Задание 2: Производитель-Потребитель с условной переменной
// В этом файле реализована потокобезопасная очередь и демонстрация
// работы производителя и нескольких потребителей. Каждая строка кода
// подробно прокомментирована для понимания принципов синхронизации.

#include <iostream>                // Заголовочный файл для ввода‑вывода
#include <queue>                   // Заголовочный файл для std::queue
#include <thread>                  // Заголовочный файл для работы с потоками std::thread
#include <mutex>                   // Заголовочный файл для использования std::mutex
#include <condition_variable>      // Заголовочный файл для std::condition_variable
#include <chrono>                  // Заголовочный файл для sleep (задержек)

// Обобщённый класс потокобезопасной очереди
template<typename T>
class ThreadSafeQueue {
private:
    std::queue<T> queue;              // Очередь, в которой хранятся элементы
    std::mutex mutex;                 // Мьютекс для защиты доступа к очереди
    std::condition_variable cond;     // Условная переменная для ожидания/оповещения потоков
    bool is_shutdown = false;         // Флаг, который сигнализирует о завершении работы очереди

public:
    // Метод push добавляет элемент в очередь в потокобезопасном режиме
    void push(T value) {
        {
            std::lock_guard<std::mutex> lock(mutex); // Захватываем мьютекс на время модификации очереди
            queue.push(std::move(value));             // Добавляем элемент в очередь, используя move для возможной оптимизации
        }                                            // По выходу из блока мьютекс автоматически освобождается
        cond.notify_one();                           // Будим один поток‑потребитель, ожидающий появления элемента
    }
    // Метод pop извлекает элемент из очереди; возвращает false, если очередь закрыта и пуста
    bool pop(T& value) {
        std::unique_lock<std::mutex> lock(mutex);    // Захватываем мьютекс с возможностью временного освобождения
        // Ожидаем, пока в очереди появится элемент или очередь не будет закрыта
        cond.wait(lock, [this]() { return is_shutdown || !queue.empty(); });
        if (queue.empty() && is_shutdown) {          // Если очередь пуста и установлен флаг завершения
            return false;                            // Возвращаем false, сигнализируя, что больше извлекать нечего
        }
        value = std::move(queue.front());            // Извлекаем значение из начала очереди, перемещая его в аргумент
        queue.pop();                                 // Удаляем элемент из очереди
        return true;                                 // Возвращаем true, указывая, что операция успешна
    }
    // Метод shutdown завершает работу очереди, уведомляя ожидающие потоки
    void shutdown() {
        {
            std::lock_guard<std::mutex> lock(mutex); // Захватываем мьютекс перед изменением флага
            is_shutdown = true;                      // Устанавливаем флаг завершения работы
        }                                            // Освобождаем мьютекс после установки флага
        cond.notify_all();                           // Оповещаем все ожидающие потоки, чтобы они могли завершиться
    }
};

// Функция‑производитель генерирует числовые значения и помещает их в очередь
void producer(ThreadSafeQueue<int>& queue, int count) {
    for (int i = 0; i < count; ++i) {                // Цикл для генерации count элементов
        queue.push(i);                               // Помещаем очередное число i в очередь
        std::this_thread::sleep_for(std::chrono::milliseconds(1)); // Делаем короткую паузу для наглядности
    }
    queue.shutdown();                                // После генерации всех элементов закрываем очередь
}

// Функция‑потребитель извлекает элементы из очереди и обрабатывает их
void consumer(ThreadSafeQueue<int>& queue, int id) {
    int value;                                       // Переменная для хранения извлечённого значения
    while (queue.pop(value)) {                       // Пока pop возвращает true, продолжаем извлекать элементы
        std::cout << "[Потребитель " << id << "] получил " << value << std::endl; // Выводим информацию о полученном элементе
        std::this_thread::sleep_for(std::chrono::milliseconds(5)); // Имитируем обработку, делая небольшую задержку
    }
    std::cout << "[Потребитель " << id << "] завершил работу" << std::endl; // Когда очередь закрыта и пуста, сообщаем о завершении
}

// Главная функция демонстрирует работу производителя и потребителей
int main() {
    ThreadSafeQueue<int> queue;                      // Создаём потокобезопасную очередь для int
    const int produce_count = 100;                   // Количество элементов, которое сгенерирует производитель
    // Запускаем поток‑производитель
    std::thread prod_thread(producer, std::ref(queue), produce_count); // Создаём поток, передавая ссылку на очередь и количество элементов
    // Запускаем несколько потоков‑потребителей
    const int num_consumers = 3;                     // Количество потоков‑потребителей
    std::vector<std::thread> consumers;              // Вектор для хранения потоков‑потребителей
    consumers.reserve(num_consumers);                // Резервируем место в векторе для num_consumers потоков
    for (int i = 0; i < num_consumers; ++i) {        // Создаём num_consumers потоков
        consumers.emplace_back(consumer, std::ref(queue), i + 1); // Добавляем новый поток‑потребитель, передавая ссылку на очередь и идентификатор
    }
    prod_thread.join();                              // Ждём завершения работы потока‑производителя
    for (auto& th : consumers) {                     // Перебираем все потоки‑потребители
        th.join();                                   // Ожидаем завершения каждого потока
    }
    return 0;                                        // Возвращаем 0, что означает успешное завершение программы
}